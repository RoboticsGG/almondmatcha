#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include <std_msgs/msg/string.hpp>
#include <std_msgs/msg/u_int8.hpp>
#include <std_msgs/msg/u_int16.hpp>
#include <std_msgs/msg/float64.hpp>
#include <std_msgs/msg/bool.hpp>
#include <std_msgs/msg/float32_multi_array.hpp>
#include <string>
#include <mutex>
#include <msgs_ifaces/msg/sub_rocon.hpp>
#include <msgs_ifaces/msg/main_rocon.hpp>
#include <services_ifaces/srv/spd_limit.hpp>

class Node_Rovercontrol : public rclcpp::Node {
public:
    Node_Rovercontrol() : Node("node_bridge") {
        // Initialize context for subscriber (Domain ID 2)
        rclcpp::InitOptions init_options_sub;
        init_options_sub.set_domain_id(2);
        rclcpp::Context::SharedPtr context_sub = std::make_shared<rclcpp::Context>();
        context_sub->init(0, nullptr, init_options_sub);

        rclcpp::NodeOptions node_options_sub;
        node_options_sub.context(context_sub);
        sub_node_ = std::make_shared<rclcpp::Node>("sub_node", node_options_sub);

        spd_service_ = sub_node_->create_service<services_ifaces::srv::SpdLimit>("spd_limit",
            std::bind(&Node_Rovercontrol::handle_spd_request, this, std::placeholders::_1, std::placeholders::_2)
        );


        topic_cc_rcon_sub_ = sub_node_->create_subscription<std_msgs::msg::Bool>(
            "tpc_gnss_mission_active", 10,
            std::bind(&Node_Rovercontrol::topic_cc_rcon_callback, this, std::placeholders::_1)
        );

         fmctl_sub_ = this->create_subscription<std_msgs::msg::Float32MultiArray>(
            "tpc_rover_fmctl", 10,
            std::bind(&Node_Rovercontrol::fmctl_callback, this, std::placeholders::_1));

        topic_rocon_pub_d2 = sub_node_->create_publisher<msgs_ifaces::msg::MainRocon>("pub_rovercontrol_d2", 10);
        

        // Initialize context for publisher (Domain ID 5)
        rclcpp::InitOptions init_options_pub;
        init_options_pub.set_domain_id(5);
        rclcpp::Context::SharedPtr context_pub = std::make_shared<rclcpp::Context>();
        context_pub->init(0, nullptr, init_options_pub);

        rclcpp::NodeOptions node_options_pub;
        node_options_pub.context(context_pub);
        pub_node_ = std::make_shared<rclcpp::Node>("pub_node", node_options_pub);

        topic_rocon_pub_ = pub_node_->create_publisher<msgs_ifaces::msg::MainRocon>("pub_rovercontrol_d5", 10);
        
        //RCLCPP_INFO(this->get_logger(), "Node_Rovercontrol initialized (Subscriber: Domain 2, Publisher: Domain 1)");
        
        executor_.add_node(sub_node_);
        executor_.add_node(pub_node_);
        executor_thread_ = std::thread([this]() { executor_.spin(); });
    }

    ~Node_Rovercontrol() {
        executor_.cancel();
        if (executor_thread_.joinable())
            executor_thread_.join();
    }

private:
    rclcpp::Node::SharedPtr sub_node_;
    rclcpp::Node::SharedPtr pub_node_;
    rclcpp::Service<services_ifaces::srv::SpdLimit>::SharedPtr spd_service_;
    //rclcpp::Subscription<std_msgs::msg::Float32MultiArray>::SharedPtr topic_direct_sub_;
    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr topic_cc_rcon_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32MultiArray>::SharedPtr fmctl_sub_;
    rclcpp::Publisher<msgs_ifaces::msg::MainRocon>::SharedPtr topic_rocon_pub_;
    rclcpp::Publisher<msgs_ifaces::msg::MainRocon>::SharedPtr topic_rocon_pub_d2;
    rclcpp::executors::MultiThreadedExecutor executor_;
    rclcpp::Time detect_zero_start_time_;
    std::thread executor_thread_;

    float ro_ctrl_msg1_;
    float ro_ctrl_msg2_;

    float steer_msg_;
    float detect_msg_;

    uint8_t spd_msg_;
    bool cc_rcon_msg_ = true;

    std::mutex data_lock_;

    void topic_cc_rcon_callback(const std_msgs::msg::Bool::SharedPtr msg) {
        std::lock_guard<std::mutex> lock(data_lock_);
        if (msg->data != cc_rcon_msg_) { 
            cc_rcon_msg_ = msg->data;
            RCLCPP_INFO(this->get_logger(), "cc_rcon updated: %s", msg->data ? "TRUE" : "FALSE");
        }   
    }

    void handle_spd_request(const std::shared_ptr<services_ifaces::srv::SpdLimit::Request> request,
                            std::shared_ptr<services_ifaces::srv::SpdLimit::Response> response) {
        std::lock_guard<std::mutex> lock(data_lock_);
        spd_msg_ = request->rover_spd;
        response->spd_result = "Speed Limit set to " + std::to_string(request->rover_spd);
        RCLCPP_INFO(this->get_logger(), "Speed Limit set to %d", request->rover_spd);
    }

    void fmctl_callback(const std_msgs::msg::Float32MultiArray::SharedPtr msg) {
        if (msg->data.size() >= 2) {
            std::lock_guard<std::mutex> lock(data_lock_);
            steer_msg_ = msg->data[0];
            detect_msg_ = msg->data[1];
        } else {
            RCLCPP_WARN(this->get_logger(), "Received insufficient data on tpc_rover_fmctl.");
        }
        Node_Rovercontrol::fmctl_callback2();
    }

    bool detect_zero_active_ = false;
    void fmctl_callback2() {
        auto subrocon = msgs_ifaces::msg::SubRocon();
        auto mainrocon = msgs_ifaces::msg::MainRocon();
        
        {
            std::lock_guard<std::mutex> lock(data_lock_);

            if (cc_rcon_msg_ == true) {
                // --- Override: stop everything ---
                subrocon.fdr_msg = 2;
                subrocon.ro_ctrl_msg = 0.0;
                subrocon.spd_msg = 0;
                subrocon.bdr_msg = 0;
            } else {
                // --- Steering logic ---
                if (steer_msg_ > 0.0) {
                    subrocon.fdr_msg = 1;
                    subrocon.ro_ctrl_msg = std::fabs(steer_msg_);
                } else if (steer_msg_ < 0.0) {
                    subrocon.fdr_msg = 3;
                    subrocon.ro_ctrl_msg = std::fabs(steer_msg_);
                } else {
                    subrocon.fdr_msg = 2;
                    subrocon.ro_ctrl_msg = 0.0;
                }

                // --- Detection / Speed logic ---
                if (detect_msg_ == 0.0) {
                    if (!detect_zero_active_) {
                        // First time detect_msg_ == 0
                        detect_zero_start_time_ = this->now();
                        detect_zero_active_ = true;
                    }

                    auto elapsed = (this->now() - detect_zero_start_time_).seconds();

                    if (elapsed >= 10.0) {
                        subrocon.spd_msg = 0;
                    } else {
                        subrocon.spd_msg = spd_msg_ / 2;
                    }
                } else {
                    // Reset timer
                    detect_zero_active_ = false;
                    subrocon.spd_msg = spd_msg_;
                }

                // --- Always forward when active ---
                subrocon.bdr_msg = 1;
            }

            // Wrap and publish
            mainrocon.mainrocon_msg = subrocon;
            topic_rocon_pub_->publish(mainrocon);
            topic_rocon_pub_d2->publish(mainrocon);
        }

        RCLCPP_INFO(this->get_logger(), "Publishing to pub_rovercontrol: [%d, %.2f, %d, %d]", 
                    mainrocon.mainrocon_msg.fdr_msg, 
                    mainrocon.mainrocon_msg.ro_ctrl_msg, 
                    mainrocon.mainrocon_msg.spd_msg, 
                    mainrocon.mainrocon_msg.bdr_msg);
        RCLCPP_INFO(this->get_logger(), "################################################");
    }

};

int main(int argc, char *argv[]) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<Node_Rovercontrol>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
